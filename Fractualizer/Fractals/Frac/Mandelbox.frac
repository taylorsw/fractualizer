fractal Mandelbox
{
	void sphereFold(ref v3 z, ref float dz)
	{
		float minRadius2 = 0.25;
		float fixedRadius2 = 1;

		float r2 = dot(z, z);
		if (r2 < minRadius2) 
		{
			// linear inner scaling
			float temp = (fixedRadius2 / minRadius2);
			z *= temp;
			dz *= temp;
		}
		else if (r2 < fixedRadius2) 
		{
			// this is the actual sphere inversion
			float temp = fixedRadius2 / r2;
			z *= temp;
			dz *= temp;
		}
	}

	void boxFold(ref v3 z, ref float dz)
	{
		float foldingLimit = 1;
		z = clamp(z, -foldingLimit, foldingLimit) * 2.0 - z;
	}

	float hash(float n)
	{
		return frac(sin(n)*43758.5453);
	}

	float noise(v3 x)
	{
		// The noise function returns a value in the range -1.0f -> 1.0f

		v3 p = floor(x);
		v3 f = frac(x);

		f = f*f*(3.0-2.0*f);
		float n = p.x + p.y*57.0 + 113.0*p.z;

		return lerp(lerp(lerp( hash(n+0.0), hash(n+1.0),f.x),
					   lerp( hash(n+57.0), hash(n+58.0),f.x),f.y),
				   lerp(lerp( hash(n+113.0), hash(n+114.0),f.x),
					   lerp( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);
	}

	DE(v3 pos)
	{
		float sf = 2;
		float sfNormalizing = 3 * (sf + 1) / (sf - 1);
		pos = pos * sfNormalizing;
		int Iterations = 20;
		v3 offset = pos;
		float dr = 1.0;
		for (int n = 0; n < Iterations; n++) {
			boxFold(pos, dr);       // Reflect
			sphereFold(pos, dr);    // Sphere Inversion

			pos = sf * pos + offset;  // Scale & Translate
			dr = dr*abs(sf) + 1.0;
		}
		float r = length(pos);
		return r / abs(dr) / sfNormalizing;
	}

	v3 Color(v3 pt)
	{
		float sfR = 1;
		float sfG = 1;
		float sfB = 1;
		float paramStandin = 8.0;
		return v3(
			sfR * sin(pt.y * 7 + paramStandin * noise(pt * 10)), 
			sfG * sin(pt.y * 8 + paramStandin * noise(pt * 10)), 
			sfB * sin(pt.x * 10 + (paramStandin / 2) * noise(pt * 10)));
		return v3(1, 1, 1);
	)
}